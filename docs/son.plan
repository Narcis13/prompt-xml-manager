Okay, let's break down the development of the SON Environment application into a detailed, step-by-step plan suitable for AI code generation.

<brainstorming>
1.  **Goal:** Create a step-by-step plan for building the SON Environment web app (Next.js client-only frontend, BunJS/SQLite backend).
2.  **Inputs:** Project Request, SON Spec, Project Rules (Next.js client-only, Tailwind, Bun backend), Technical Specification (detailed architecture, components, DB schema, API), Starter Template (Bun/SQLite/WebSocket base).
3.  **Key Constraints:**
    *   Strictly client-side Next.js (`"use client"` everywhere). No Next.js API routes or Server Components.
    *   Backend is a separate BunJS server handling API requests and DB interaction.
    *   Frontend uses Tailwind CSS.
    *   SON interpreter runs client-side in JS.
    *   State synchronization between client `$env` and backend DB is manual (explicit save + refresh).
4.  **Core Modules/Areas:**
    *   Project Setup (Client + Server)
    *   Backend: DB Schema, API Endpoints (CRUD for classes/methods, base env)
    *   Frontend: Core Layout, Tailwind Setup, API Client Lib
    *   SON Interpreter: Core JS implementation, Environment management
    *   Frontend State Management: React Context for `$env`
    *   UI Components: IDE Layout, Workspace, System Browser (ClassList, MethodList, CodeViewer), ConsoleOutput
    *   Integration: Connecting UI, interpreter, API client, state management.
    *   JS Interoperability (`JSBridge`)
    *   Testing
5.  **Plan Strategy:**
    *   **Foundation:** Set up both client and server project structures.
    *   **Backend First:** Implement the DB and the API endpoints. This decouples the frontend development initially. Start with read endpoints, then write. Adapt the starter template server.
    *   **Frontend Shell:** Set up Next.js, Tailwind, basic layout.
    *   **API Client:** Implement the frontend service to talk to the backend.
    *   **Interpreter Core:** Develop the SON interpreter incrementally, starting with basics. Unit test heavily.
    *   **State Management:** Set up the React Context for the `$env`.
    *   **UI Build-out:** Implement UI components, connecting them to the API client for data fetching (System Browser) and the interpreter/context for execution (Workspace).
    *   **Feature Integration:** Wire up execution, saving, console output, JS bridge.
    *   **Testing & Polish:** Add tests and refine UI/UX.
6.  **Step Granularity:** Each step should be manageable for an AI, ideally modifying <10 files and focusing on one specific task (e.g., setting up DB schema, implementing one API endpoint, creating one component, adding one feature to the interpreter).
7.  **Adapting Starter Template:** The backend `server.js` needs significant changes: replace agent/message logic with SON class/method logic, update DB schema, change API routes. Keep the basic Bun server setup, SQLite integration, and optionally WebSocket structure (though WS isn't MVP). The frontend `index.html` is entirely replaced by the Next.js app.
8.  **Key Decisions Recap:**
    *   Classes = Named objects in DB (`son_classes`) linked to methods.
    *   Base Env = Loaded via `/api/base-environment`.
    *   State Sync = Explicit save + refresh/reload.
    *   Non-local returns = Handled via JS Errors/exceptions in interpreter.
    *   Next.js = Client components only (`"use client"`).

</brainstorming>

# Implementation Plan

## Phase 1: Project Setup and Backend Core

-   [x] **Step 1: Initialize Project Structure and Dependencies**
    *   **Task**: Create the root directory, `client` and `server` subdirectories. Initialize the Next.js project in `client` and a basic Bun project in `server`. Set up `.gitignore`.
    *   **Files**:
        *   `son-environment/.gitignore`: Add basic Node, Bun, Next.js, OS ignores (`node_modules`, `.next`, `out`, `build`, `*.sqlite`, `*.sqlite-journal`).
        *   `son-environment/client/package.json`: Generated by `create-next-app`.
        *   `son-environment/client/next.config.mjs`: Basic Next.js config (ensure no experimental server features are enabled by default).
        *   `son-environment/client/tsconfig.json`: Generated by `create-next-app`.
        *   `son-environment/server/package.json`: Basic `package.json` for Bun (e.g., `{"name": "son-server", "module": "server.ts", "type": "module"}`). Add `bun-types`.
        *   `son-environment/server/tsconfig.json`: Basic TSConfig for Bun server (e.g., target ESNext, module ESNext, strict).
    *   **Step Dependencies**: None.
    *   **User Instructions**:
        1.  Create the root directory `son-environment`.
        2.  Inside `son-environment`, run `bun create next ./client --typescript --tailwind --eslint --app --src-dir --import-alias "@/*"`.
        3.  Inside `son-environment`, create the `server` directory.
        4.  Inside `son-environment/server`, run `bun init -y`. Edit `package.json` as described above. Run `bun add bun-types --dev`. Create `tsconfig.json`.

-   [x] **Step 2: Setup SQLite Database and Schema**
    *   **Task**: Create the database initialization script in the Bun backend. Define the SQLite schema for `son_classes`, `son_methods`, and `son_base_environment` as specified in the technical specification. Ensure the database file is created if it doesn't exist.
    *   **Files**:
        *   `son-environment/server/db.ts`: Implement database connection logic using `bun:sqlite`. Include functions/statements to create the tables (`son_classes`, `son_methods`, `son_base_environment`) with specified columns, types, constraints, and indexes. Export the `db` instance. Create a directory `data` if needed.
    *   **Step Dependencies**: Step 1.
    *   **User Instructions**: Run `bun install` in the `server` directory if not already done.

-   [x] **Step 3: Implement Basic Bun Server and API Routing**
    *   **Task**: Adapt the starter `server.js` (renaming to `server.ts`). Set up the main Bun server using `Bun.serve`. Define basic routing structure for API endpoints (`/api/...`). Remove agent/message/file logic from the starter template. Keep WebSocket setup but make handlers minimal (connect/disconnect logging). Add basic root/not-found handling.
    *   **Files**:
        *   `son-environment/server/server.ts`: Initialize the server, import `db` from `db.ts`. Set up basic request handling using `URL` and `req.method`. Add stubs for API routes. Implement minimal WebSocket handlers (`open`, `close`, `message`). Log server start.
    *   **Step Dependencies**: Step 1, Step 2.
    *   **User Instructions**: Ensure `bun:sqlite` is available (comes with Bun).

-   [x] **Step 4: Implement Backend Read API Endpoints**
    *   **Task**: Implement the GET API endpoints for reading data: `/api/base-environment`, `/api/classes`, `/api/methods/{className}`, `/api/method/{className}/{selector}`. Fetch data from the SQLite database using handlers.
    *   **Files**:
        *   `son-environment/server/api/environmentHandlers.ts`: Create handler function `getBaseEnvironment(db)` to fetch and format data from `son_base_environment`.
        *   `son-environment/server/api/persistenceHandlers.ts`: Create handler functions `getClasses(db)`, `getMethods(db, className)`, `getMethodSource(db, className, selector)` to query the `son_classes` and `son_methods` tables. Handle parsing of JSON strings from DB. Include error handling (e.g., 404 Not Found).
        *   `son-environment/server/server.ts`: Import handlers and wire them up to the corresponding API routes (GET requests). Handle URL parameters (`className`, `selector`).
    *   **Step Dependencies**: Step 2, Step 3.
    *   **User Instructions**: Can manually add some test data to `son_environment.sqlite` using a tool like DB Browser for SQLite to test the endpoints.

-   [x] **Step 5: Implement Backend Write API Endpoint**
    *   **Task**: Implement the POST API endpoint `/api/method` to save or update method definitions. Handle class creation if it doesn't exist. Validate input data.
    *   **Files**:
        *   `son-environment/server/api/persistenceHandlers.ts`: Add handler function `saveMethod(db, data)` which takes the parsed request body. Implement the logic to find/create the class ID and insert/update the method in `son_methods`, storing arguments and body as JSON strings. Use transactions for safety.
        *   `son-environment/server/server.ts`: Wire up the POST `/api/method` route to the `saveMethod` handler. Include request body parsing (`req.json()`) and error handling (400 Bad Request, 500 Internal Server Error).
    *   **Step Dependencies**: Step 2, Step 3, Step 4.

## Phase 2: Frontend Foundation and Core Logic

-   [x] **Step 6: Configure Next.js Client and Tailwind CSS**
    *   **Task**: Set up the basic Next.js application structure (`app/layout.tsx`, `app/page.tsx`). Ensure all components use `"use client"`. Configure Tailwind CSS (`tailwind.config.js`, `globals.css`). Create a basic root layout.
    *   **Files**:
        *   `son-environment/client/tailwind.config.js`: Configure Tailwind theme (colors, fonts) as per the design system notes (minimalist). Ensure `content` includes `./src/**/*.{js,ts,jsx,tsx,mdx}`.
        *   `son-environment/client/src/styles/globals.css`: Include Tailwind directives (`@tailwind base; @tailwind components; @tailwind utilities;`). Add minimal base styles if needed.
        *   `son-environment/client/src/app/layout.tsx`: Create root layout component. Add `"use client";`. Include `<html>`, `<body>`. Import `globals.css`. Wrap children in a basic structure (e.g., main tag with flex column).
        *   `son-environment/client/src/app/page.tsx`: Create the main page component. Add `"use client";`. Render basic placeholder content (e.g., `<h1>SON Environment</h1>`).
    *   **Step Dependencies**: Step 1.
    *   **User Instructions**: Run `bun install` in the `client` directory. Run `bun run dev` in `client` to verify setup.

-   [x] **Step 7: Create Frontend API Client Service**
    *   **Task**: Implement a typed service/library for making requests to the BunJS backend API endpoints defined in Phase 1. Use `fetch`. Define interfaces/types for API request bodies and response payloads.
    *   **Files**:
        *   `son-environment/client/src/lib/apiClient.ts`: Create async functions (`getBaseEnvironment`, `getClasses`, `getMethods`, `getMethodSource`, `saveMethod`). Use `fetch` to call the backend URLs. Handle JSON parsing, response status checking, and basic error handling (throwing errors on failure). Define associated TypeScript types/interfaces (e.g., `ClassListResponse`, `MethodListResponse`, `MethodSourceRequest`, `SaveMethodPayload`).
    *   **Step Dependencies**: Step 4, Step 5.

-   [x] **Step 8: Implement Core SON Interpreter - Literals, Vars, Basic Messages**
    *   **Task**: Create the basic structure for the SON interpreter. Implement the `evaluate` function handling literals (numbers, strings, booleans, null), symbols (`{"#": "symbol"}`), variable lookup (`$x`), sequences, and *basic* unary/binary message sends (initially assuming methods are simple JS functions attached to objects). Define basic error types.
    *   **Files**:
        *   `son-environment/client/src/lib/son/types.ts`: Define core types (`SonValue`, `SonObject`, `SonSymbol`, `SonEnvironment` structure).
        *   `son-environment/client/src/lib/son/errors.ts`: Define custom error classes (`SonError`, `VariableNotFoundError`, `MessageNotUnderstoodError`).
        *   `son-environment/client/src/lib/son/environment.ts`: Implement a basic `SonEnvironment` class or object factory with `get` and `set` methods, potentially supporting prototype chains for scope.
        *   `son-environment/client/src/lib/son/interpreter.ts`: Implement the main `evaluate(node, env)` function. Handle the specified basic constructs using type/structure checking. Implement `lookupMethod` helper (basic version).
    *   **Step Dependencies**: Step 6.
    *   **User Instructions**: Add unit tests for the implemented interpreter features (requires a test runner setup - see Phase 5).

-   [x] **Step 9: Set Up SON Environment State Management (React Context)**
    *   **Task**: Create a React Context to manage the global SON execution environment (`$env`). Implement a provider that initializes the environment, potentially fetching the base environment via `apiClient`. Provide the environment object and functions to interact with it (e.g., reload).
    *   **Files**:
        *   `son-environment/client/src/contexts/SonEnvironmentContext.tsx`: Define the context (`SonEnvironmentContext`), create a provider component (`SonEnvironmentProvider`). The provider uses `useState` and `useEffect` to manage the `$env` object. Include a function `loadBaseEnvironment` that calls `apiClient.getBaseEnvironment()` and merges the result into the `$env` state.
        *   `son-environment/client/src/hooks/useSonEnvironment.ts`: (Optional but good practice) Create a custom hook `useSonEnvironment` to easily access the context value.
        *   `son-environment/client/src/app/layout.tsx`: Wrap the `children` with the `SonEnvironmentProvider`.
    *   **Step Dependencies**: Step 7, Step 8.

## Phase 3: Building the IDE Interface

-   [x] **Step 10: Create IDE Main Layout Component**
    *   **Task**: Implement the main `IDE` component that structures the user interface into areas for the Workspace and System Browser using Tailwind CSS (Flexbox/Grid).
    *   **Files**:
        *   `son-environment/client/src/components/IDE.tsx`: Create the main layout component (`"use client"`). Use Flexbox or Grid to define the structure (e.g., a sidebar for the browser, main area for the workspace, or two main columns). Render placeholder divs for `Workspace` and `SystemBrowser`.
        *   `son-environment/client/src/app/page.tsx`: Render the `<IDE />` component.
    *   **Step Dependencies**: Step 6.

-   [ ] **Step 11: Implement System Browser - Class List**
    *   **Task**: Create the `SystemBrowser` container component and the `ClassList` component. `ClassList` should fetch the list of class names from the backend API on mount and display them as a clickable list. Manage selected class state.
    *   **Files**:
        *   `son-environment/client/src/components/ui/Panel.tsx`: (Optional) Create a simple reusable Panel component for consistent styling.
        *   `son-environment/client/src/components/ui/ListView.tsx`: (Optional) Create a generic list view component.
        *   `son-environment/client/src/components/ClassList.tsx`: (`"use client"`) Fetch classes using `apiClient.getClasses()` in `useEffect`. Store classes and loading/error states in `useState`. Render the list. Handle clicks to set the selected class name (pass selection state up via callback or context).
        *   `son-environment/client/src/components/SystemBrowser.tsx`: (`"use client"`) Render `ClassList`. Manage the `selectedClassName` state using `useState`. Pass state/setter down to `ClassList`. Render placeholder for MethodList and CodeViewer. Use Panels if created.
        *   `son-environment/client/src/components/IDE.tsx`: Render the `<SystemBrowser />` component in its designated area.
    *   **Step Dependencies**: Step 7, Step 9, Step 10.

-   [ ] **Step 12: Implement System Browser - Method List**
    *   **Task**: Create the `MethodList` component. It should receive the selected class name as a prop and fetch/display the corresponding method selectors from the API. Manage selected method state.
    *   **Files**:
        *   `son-environment/client/src/components/MethodList.tsx`: (`"use client"`) Accept `selectedClassName` and `onMethodSelect` callback as props. Use `useEffect` to fetch methods via `apiClient.getMethods(selectedClassName)` when the class name changes. Store methods, loading, error states. Render the list of selectors. Call `onMethodSelect` on click.
        *   `son-environment/client/src/components/SystemBrowser.tsx`: Render `MethodList`, passing `selectedClassName` and managing `selectedMethodSelector` state.
    *   **Step Dependencies**: Step 7, Step 11.

-   [ ] **Step 13: Implement System Browser - Code Viewer**
    *   **Task**: Create the `CodeViewer` component. It should receive the selected class name and method selector as props, fetch the method's SON source code from the API, and display it (pretty-printed JSON).
    *   **Files**:
        *   `son-environment/client/src/components/CodeViewer.tsx`: (`"use client"`) Accept `className` and `selector` as props. Use `useEffect` to fetch source via `apiClient.getMethodSource(className, selector)` when props change. Store source code JSON, loading, error states. Display the fetched JSON using `<pre>` and `JSON.stringify(..., null, 2)` or integrate a simple JSON viewer/editor component in read-only mode (e.g., `react-simple-code-editor` configured as read-only).
        *   `son-environment/client/src/components/SystemBrowser.tsx`: Render `CodeViewer`, passing `selectedClassName` and `selectedMethodSelector`.
    *   **Step Dependencies**: Step 7, Step 12.

-   [ ] **Step 14: Implement Workspace - Editor and Basic Layout**
    *   **Task**: Create the `Workspace` component structure with areas for the code editor, control buttons, results display, and console output. Integrate a code editor component for SON JSON input.
    *   **Files**:
        *   `son-environment/client/src/components/ui/Button.tsx`: (Optional) Create a reusable Button component.
        *   `son-environment/client/src/components/Workspace.tsx`: (`"use client"`) Set up layout using Flexbox/Grid/Panels. Integrate a code editor (e.g., `react-simple-code-editor` or Monaco/CodeMirror basic setup for JSON). Manage editor content using `useState`. Add placeholder buttons ("Execute", "Save Method") and areas for results/console.
        *   `son-environment/client/src/components/IDE.tsx`: Render the `<Workspace />` component in its designated area.
    *   **Step Dependencies**: Step 10.
    *   **User Instructions**: May need to install a code editor library: `bun add react-simple-code-editor` (or other chosen library).

-   [ ] **Step 15: Implement Workspace - Code Execution**
    *   **Task**: Wire up the "Execute" button in the `Workspace`. On click, parse the JSON from the editor, retrieve the current `$env` from `SonEnvironmentContext`, call the `evaluate` function from the SON interpreter, and display the result or error message in the results area.
    *   **Files**:
        *   `son-environment/client/src/components/Workspace.tsx`: Implement the `handleExecute` function. Use `try...catch` around `JSON.parse` and `evaluate`. Update `useState` variables for `result` and `error` display. Access `$env` using `useContext(SonEnvironmentContext)`. Render the result/error state in the designated panel.
    *   **Step Dependencies**: Step 8, Step 9, Step 14.

## Phase 4: Advanced Features and Integration

-   [ ] **Step 16: Enhance SON Interpreter - Assignments, Keywords, Cascades**
    *   **Task**: Extend the `evaluate` function in the SON interpreter to handle assignments (`["var:", expr]`), keyword message sends (`["receiver", "selector:arg:", arg1, ...]`), and cascades (`["receiver", "cascade:", [msg1, ...]]`). Update `SonEnvironment` if needed for assignment scope.
    *   **Files**:
        *   `son-environment/client/src/lib/son/interpreter.ts`: Add logic branches to `evaluate` for these constructs. Refine `lookupMethod` to handle keyword selectors. Update tests.
        *   `son-environment/client/src/lib/son/environment.ts`: Ensure `set` handles assignment semantics correctly (potentially updating the defining environment scope).
    *   **Step Dependencies**: Step 8.
    *   **User Instructions**: Add relevant unit tests.

-   [ ] **Step 17: Enhance SON Interpreter - Blocks and Returns (Non-Local)**
    *   **Task**: Implement support for block closures (`[["args"], "=>:", [body...]]`) including capturing the lexical environment. Implement return statements (`["^", expr]`), handling both local returns from methods and non-local returns from blocks using the Error-based mechanism described in the spec. This is complex.
    *   **Files**:
        *   `son-environment/client/src/lib/son/interpreter.ts`:
            *   Add logic to create block closure objects/functions capturing `args`, `body`, and `env`.
            *   Implement the `value:` (and potentially `value:value:`, etc.) message handling for blocks, creating new environments with arguments bound.
            *   Implement `["^", expr]` evaluation, throwing `LocalReturnError` or `NonLocalReturnError`.
            *   Modify message send evaluation and block evaluation to wrap calls to `evaluate` in `try...catch` blocks to handle these return errors correctly, propagating `NonLocalReturnError` up the stack until the defining method context is found.
        *   `son-environment/client/src/lib/son/errors.ts`: Define `LocalReturnError` and `NonLocalReturnError` containing the return value and potentially target context information.
        *   `son-environment/client/src/lib/son/types.ts`: Define types for Block closures.
    *   **Step Dependencies**: Step 8, Step 16.
    *   **User Instructions**: Add comprehensive unit tests for block creation, execution, scoping, and various return scenarios.

-   [ ] **Step 18: Implement Workspace - Console Output (`Transcript`)**
    *   **Task**: Implement the SON `Transcript` functionality. Define a `Transcript` object with a `show:` method in the base environment or inject it during execution. Calls to `Transcript show:` should append messages to a state managed by `Workspace`, displayed in the console output area.
    *   **Files**:
        *   `son-environment/client/src/components/ConsoleOutput.tsx`: Create a component to display an array of console messages (`"use client"`).
        *   `son-environment/client/src/components/Workspace.tsx`: Add state `consoleOutput` (`useState<string[]>([])`). Modify `handleExecute` to inject a `Transcript` object into the execution environment before calling `evaluate`. The `Transcript` object's `show:` method should be a JS function that calls `setConsoleOutput(prev => [...prev, String(message)])`. Render the `ConsoleOutput` component, passing the state. Clear `consoleOutput` state at the start of `handleExecute`.
        *   *(Optional - Backend)*: `son-environment/server/api/environmentHandlers.ts` / DB Seed: Define a base `Transcript` object in `son_base_environment` if preferring it to be part of the persisted base env (though dynamic injection might be simpler).
    *   **Step Dependencies**: Step 15.

-   [ ] **Step 19: Implement Workspace - Save Method Functionality**
    *   **Task**: Implement the "Save Method" button logic. Add UI elements (or parsing logic) to determine the target class name and selector. Parse the method definition (args, body) from the editor content. Call the `apiClient.saveMethod` function and provide user feedback (success/error message). Remind user refresh is needed.
    *   **Files**:
        *   `son-environment/client/src/components/Workspace.tsx`: Implement `handleSave` function.
            *   Add state/input for target class name (or parse from `["define:args:body:", ...]`).
            *   Parse the editor content (`JSON.parse`). Validate it's a method definition structure (`["define:args:body:", selector, args, body]`). Extract components.
            *   Call `apiClient.saveMethod` with extracted data.
            *   Use `alert` or a status message area to show success/failure. Add a note like "Refresh browser or reload environment to see changes."
    *   **Step Dependencies**: Step 5, Step 7, Step 15.

-   [ ] **Step 20: Implement Base Environment Loading and JS Bridge**
    *   **Task**: Ensure the base environment (including core object methods and the `JSBridge`) is loaded correctly via the API and merged into the `$env` by the `SonEnvironmentContext`. Implement the `JSBridge` object with methods (`log:`, `fetch:options:`, `setTimeout:delay:`) and the interpreter mechanism to call the corresponding JS functions. Seed the `son_base_environment` table.
    *   **Files**:
        *   `son-environment/client/src/contexts/SonEnvironmentContext.tsx`: Ensure `loadBaseEnvironment` correctly merges the fetched base environment structure into the `$env` state. Handle potential merging conflicts if needed. Call `loadBaseEnvironment` on initial mount.
        *   `son-environment/client/src/lib/son/interpreter.ts`: Modify message send logic. If the receiver is the `JSBridge` object (or has a special flag), look up the selector on the JS object itself and call the corresponding JS function directly, handling arguments and return values (including Promises from `fetch`).
        *   `son-environment/server/db.ts` (or a separate seed script): Add code to populate the `son_base_environment` table with definitions for basic types (Number, String methods), `Transcript` (if persisted), and `JSBridge` with its methods defined as placeholder SON (or just structure). The actual JS implementation is client-side.
    *   **Step Dependencies**: Step 4, Step 9, Step 17.
    *   **User Instructions**: Run the seed script or manually populate the `son_base_environment` table in `server/data/son_environment.sqlite`. Test calling JS bridge methods from the Workspace.

## Phase 5: Testing and Finalization

-   [ ] **Step 21: Implement Unit Tests for SON Interpreter**
    *   **Task**: Write comprehensive unit tests for the SON interpreter (`evaluate` function and `SonEnvironment`). Cover all SON constructs, scoping rules, return semantics, error conditions, and the JS bridge mechanism.
    *   **Files**:
        *   `son-environment/client/src/lib/son/interpreter.test.ts`: Test suite for `evaluate`.
        *   `son-environment/client/src/lib/son/environment.test.ts`: Test suite for `SonEnvironment`.
        *   `son-environment/client/package.json`: Add testing libraries (e.g., `vitest`, `@testing-library/react`).
        *   `son-environment/client/vitest.config.ts` (or similar): Configure the test runner.
    *   **Step Dependencies**: Step 8, Step 16, Step 17, Step 20.
    *   **User Instructions**: Run `bun install` in `client`. Run the test command (e.g., `bun run test`).

-   [ ] **Step 22: Implement Integration Tests for Key Workflows**
    *   **Task**: Write integration tests for the client application. Test interactions between components, context, API client (mocked), and the interpreter. Focus on core workflows: executing code in Workspace, browsing classes/methods, saving a method (mocking API).
    *   **Files**:
        *   `son-environment/client/src/components/Workspace.test.tsx`: Test Workspace execution flow, console output.
        *   `son-environment/client/src/components/SystemBrowser.test.tsx`: Test fetching and displaying classes/methods (mocking `apiClient`).
        *   (Potentially more tests for component interactions)
    *   **Step Dependencies**: Step 11-15, Step 18-19, Step 21.
    *   **User Instructions**: Ensure testing libraries are installed. Run tests.

-   [ ] **Step 23: Styling Refinements and Final Polish**
    *   **Task**: Review and refine the overall application styling using Tailwind CSS. Ensure consistency, responsiveness (basic), and usability. Improve error messages and user feedback.
    *   **Files**:
        *   Various `.tsx` files in `client/src/components/`: Adjust Tailwind classes.
        *   `client/src/styles/globals.css`: Minor global adjustments if needed.
    *   **Step Dependencies**: All UI components (Step 10-14, 18).

-   [ ] **Step 24: Documentation (README)**
    *   **Task**: Update the project's main README file with setup instructions (client and server), how to run the application, a brief overview of the SON dialect supported, and how to use the IDE features. Add `<ai_info>` comments to key files if not already done.
    *   **Files**:
        *   `son-environment/README.md`: Write comprehensive documentation.
        *   Add `<ai_info>` comment blocks to the top of key `.ts` / `.tsx` files describing their purpose (as indicated in the spec's file structure).
    *   **Step Dependencies**: All previous steps.

# Summary

This plan follows a phased approach:

1.  **Foundation:** Sets up the project structure and backend API/DB, establishing the persistence layer.
2.  **Frontend Core:** Initializes the Next.js app, API client, basic interpreter, and state management context.
3.  **IDE Build-out:** Constructs the UI components (System Browser, Workspace) piece by piece, connecting them to the API and initial interpreter functionality.
4.  **Advanced Features:** Enhances the interpreter with complex SON features (blocks, returns) and integrates core functionalities like execution, console output, saving, and JS interoperability.
5.  **Testing & Finalization:** Focuses on testing (unit, integration), styling refinement, and documentation.

Key considerations:

*   **Backend First:** The backend API is established early to allow parallel or independent frontend development.
*   **Incremental Interpreter:** The SON interpreter is built incrementally, allowing basic execution early and adding complexity later. Testing at each stage is crucial.
*   **Client-Only:** Strict adherence to `"use client"` in Next.js is maintained throughout.
*   **State Management:** React Context is used for the shared `$env`, keeping state management relatively simple for the MVP. Explicit refresh is required for backend updates to reflect in the client environment.
*   **Testing:** Unit tests for the interpreter and integration tests for UI workflows are essential for correctness.
*   **Starter Template Adaptation:** The backend starter code requires significant modification to fit the SON Environment's specific needs, removing unrelated features and adding new ones. The frontend starter is discarded in favor of Next.js.